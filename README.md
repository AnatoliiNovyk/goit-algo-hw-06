# goit-algo-hw-06
## Домашнє завдання №6: Алгоритми на графах
У цьому домашньому завданні ми досліджуємо основні алгоритми на графах, використовуючи бібліотеку networkX у Python. Ми змоделюємо реальну мережу, реалізуємо алгоритми пошуку шляхів (DFS, BFS), а також знайдемо найкоротші маршрути за допомогою алгоритму Дейкстри.

### Завдання 1: Моделювання та аналіз реальної мережі
Для першого завдання я створив модель транспортної мережі, що сполучає великі міста України. Цей граф є неорієнтованим, де вершини — це міста, а ребра — основні автомобільні шляхи між ними.

Код для створення та візуалізації графа

```python
import networkx as nx
import matplotlib.pyplot as plt

# Створення неорієнтованого графа
G = nx.Graph()

# Додавання вузлів (міст)
cities = ["Київ", "Львів", "Одеса", "Харків", "Дніпро", "Запоріжжя", "Вінниця", "Полтава", "Черкаси", "Кривий Ріг"]
G.add_nodes_from(cities)

# Додавання ребер (доріг між містами)
edges = [
    ("Київ", "Вінниця"), ("Київ", "Черкаси"), ("Київ", "Полтава"),
    ("Вінниця", "Львів"), ("Вінниця", "Одеса"),
    ("Одеса", "Черкаси"), ("Одеса", "Кривий Ріг"),
    ("Черкаси", "Полтава"), ("Черкаси", "Дніпро"),
    ("Полтава", "Харків"), ("Полтава", "Дніпро"),
    ("Дніпро", "Харків"), ("Дніпро", "Запоріжжя"), ("Дніпро", "Кривий Ріг"),
    ("Запоріжжя", "Кривий Ріг")
]
G.add_edges_from(edges)

# Візуалізація графа
plt.figure(figsize=(10, 8))
pos = nx.spring_layout(G, seed=42)  # для відтворюваності розташування вузлів
nx.draw(G, pos, with_labels=True, node_size=2500, node_color='skyblue', font_size=12, font_weight='bold', edge_color='gray')
plt.title("Транспортна мережа міст України")
plt.show()
```

![](https://github.com/AnatoliiNovyk/goit-algo-hw-06/blob/main/images/graph_citys.png)


**Аналіз основних характеристик графа**

Проведемо аналіз базових метрик створеного графа.

```python
# Аналіз характеристик графа
num_nodes = G.number_of_nodes()
num_edges = G.number_of_edges()
degrees = dict(G.degree())

print(f"Кількість вершин (міст): {num_nodes}")
print(f"Кількість ребер (шляхів): {num_edges}")
print("\nСтупені вершин (кількість зв'язків для кожного міста):")
for city, degree in degrees.items():
    print(f"- {city}: {degree}")
```

#### Результати аналізу:

- Кількість вершин (міст): 10 
- Кількість ребер (шляхів): 15 
- Ступені вершин: 
	- Київ: 3
	- Львів: 1
	- Одеса: 3
	- Харків: 2
	- Дніпро: 5
	- Запоріжжя: 2
	- Вінниця: 3
	- Полтава: 4
	- Черкаси: 4
	- Кривий Ріг: 3

#### Висновки:
**Місто Дніпро є найбільшим транспортним вузлом у даній моделі з найвищим ступенем (5), тоді як Львів є кінцевим вузлом, з'єднаним лише з Вінницею.**

------------

### Завдання 2: Алгоритми DFS та BFS
**На цьому етапі ми реалізуємо алгоритми пошуку в глибину (DFS) та в ширину (BFS) для знаходження шляхів у створеному графі.** 


#### Програмна реалізація DFS та BFS
Я реалізував два алгоритми для пошуку шляху між двома заданими містами: від Львова до Харкова.

```python
# Реалізація DFS для пошуку шляху
def dfs_path(graph, start, goal):
    stack = [(start, [start])]
    visited = {start}
    while stack:
        (vertex, path) = stack.pop()
        for neighbor in set(graph.neighbors(vertex)) - visited:
            if neighbor == goal:
                return path + [neighbor]
            visited.add(neighbor)
            stack.append((neighbor, path + [neighbor]))

# Реалізація BFS для пошуку шляху
def bfs_path(graph, start, goal):
    queue = [(start, [start])]
    visited = {start}
    while queue:
        (vertex, path) = queue.pop(0)
        for neighbor in set(graph.neighbors(vertex)) - visited:
            if neighbor == goal:
                return path + [neighbor]
            visited.add(neighbor)
            queue.append((neighbor, path + [neighbor]))

# Пошук шляхів між Львовом та Харковом
start_node = "Львів"
end_node = "Харків"

dfs_route = dfs_path(G, start_node, end_node)
bfs_route = bfs_path(G, start_node, end_node)

print(f"Шлях знайдений за допомогою DFS: {dfs_route}")
print(f"Шлях знайдений за допомогою BFS: {bfs_route}")
```


#### Порівняння результатів та обґрунтування
**Результати пошуку:**

- **Шлях, знайдений за допомогою DFS:** ['Львів', 'Вінниця', 'Одеса', 'Кривий Ріг', 'Запоріжжя', 'Дніпро', 'Харків']
- **Шлях, знайдений за допомогою BFS:** ['Львів', 'Вінниця', 'Київ', 'Полтава', 'Харків']


#### Пояснення різниці: 

**1.Пошук у глибину (DFS):** Цей алгоритм працює за принципом "йди якомога глибше".  Починаючи зі Львова, він рухається до першого сусіда (Вінниця), потім до першого сусіда Вінниці (крім Львова), і так далі. У моїй реалізації він обрав шлях через Одесу, Кривий Ріг, Запоріжжя і Дніпро, перш ніж досягти Харкова. DFS не гарантує знаходження найкоротшого шляху; він знаходить будь-який шлях, досліджуючи одну гілку графа повністю, перш ніж повернутися до інших. 

**2.Пошук у ширину (BFS):** Цей алгоритм досліджує граф по рівнях.  Він спочатку відвідує всіх сусідів стартової вершини, потім сусідів цих сусідів і т.д. Починаючи зі Львова, він знайшов Вінницю (рівень 1). Потім він дослідив усіх сусідів Вінниці (Київ та Одеса, рівень 2). Далі він перевірив сусідів Києва та Одеси (рівень 3) і знайшов шлях до Харкова через Київ та Полтаву. BFS завжди знаходить найкоротший шлях у незваженому графі за кількістю ребер, оскільки він систематично розширюється від стартової точки.

#### Обґрунтування: 
**Різниця у шляхах є прямим наслідком механіки роботи алгоритмів. DFS використовує стек (LIFO), що веде його вглиб по одному маршруту. BFS використовує чергу (FIFO), що змушує його досліджувати граф пошарово, гарантуючи оптимальність шляху за кількістю пройдених вершин.**

------------

### Завдання 3: Алгоритм Дейкстри
**Тепер додамо ваги до ребер нашого графа, які представлятимуть відстань між містами, і використаємо алгоритм Дейкстри для знаходження найкоротшого шляху.** 

#### Додавання ваг та реалізація алгоритму
Я додав ваги (приблизні відстані у км) до графа і використав вбудовану в networkX функцію для алгоритму Дейкстри.

```python
# Додавання ваг до ребер (відстані в км)
weighted_edges = [
    ("Київ", "Вінниця", {'weight': 267}), ("Київ", "Черкаси", {'weight': 190}), ("Київ", "Полтава", {'weight': 342}),
    ("Вінниця", "Львів", {'weight': 365}), ("Вінниця", "Одеса", {'weight': 442}),
    ("Одеса", "Черкаси", {'weight': 447}), ("Одеса", "Кривий Ріг", {'weight': 294}),
    ("Черкаси", "Полтава", {'weight': 270}), ("Черкаси", "Дніпро", {'weight': 272}),
    ("Полтава", "Харків", {'weight': 143}), ("Полтава", "Дніпро", {'weight': 195}),
    ("Дніпро", "Харків", {'weight': 218}), ("Дніпро", "Запоріжжя", {'weight': 82}), ("Дніпро", "Кривий Ріг", {'weight': 150}),
    ("Запоріжжя", "Кривий Ріг", {'weight': 165})
]

# Створення нового графа з вагами
G_weighted = nx.Graph()
G_weighted.add_nodes_from(cities)
G_weighted.add_edges_from(weighted_edges)

# Пошук найкоротших шляхів від Львова до всіх інших міст за допомогою алгоритму Дейкстри
start_city = "Львів"
shortest_paths = nx.single_source_dijkstra_path(G_weighted, source=start_city)
shortest_path_lengths = nx.single_source_dijkstra_path_length(G_weighted, source=start_city)

print(f"Найкоротші шляхи від міста {start_city}:\n")
for city, path in shortest_paths.items():
    length = shortest_path_lengths[city]
    print(f"До міста {city}:")
    print(f"  - Шлях: {' -> '.join(path)}")
    print(f"  - Відстань: {length} км\n")

# Візуалізація зваженого графа
plt.figure(figsize=(12, 10))
pos = nx.spring_layout(G_weighted, seed=42)
labels = nx.get_edge_attributes(G_weighted, 'weight')
nx.draw(G_weighted, pos, with_labels=True, node_size=2500, node_color='lightgreen', font_size=12, font_weight='bold')
nx.draw_networkx_edge_labels(G_weighted, pos, edge_labels=labels)
plt.title("Зважена транспортна мережа міст України (відстані в км)")
plt.show()
```

#### Результати та висновки
**Найкоротші шляхи від міста Львів:**

- До міста Львів:
  - Шлях: Львів
  - Відстань: 0 км
- До міста Вінниця:
  - Шлях: Львів -> Вінниця
  - Відстань: 365 км
- До міста Київ:
  - Шлях: Львів -> Вінниця -> Київ
  - Відстань: 632 км
- До міста Одеса:
  - Шлях: Львів -> Вінниця -> Одеса
  - Відстань: 807 км
- До міста Черкаси:
  - Шлях: Львів -> Вінниця -> Київ -> Черкаси
  - Відстань: 822 км
- До міста Полтава:
  - Шлях: Львів -> Вінниця -> Київ -> Полтава
  - Відстань: 974 км
- До міста Кривий Ріг:
  - Шлях: Львів -> Вінниця -> Одеса -> Кривий Ріг
  - Відстань: 1101 км
- До міста Дніпро:
  - Шлях: Львів -> Вінниця -> Київ -> Черкаси -> Дніпро
  - Відстань: 1094 км
- До міста Харків:
  - Шлях: Львів -> Вінниця -> Київ -> Полтава -> Харків
  - Відстань: 1117 км
- До міста Запоріжжя:
  - Шлях: Львів -> Вінниця -> Київ -> Черкаси -> Дніпро -> Запоріжжя
  - Відстань: 1176 км

#### Висновки:
**Алгоритм Дейкстри успішно знаходить найкоротший шлях у зваженому графі, враховуючи "вартість" кожного ребра (у нашому випадку — відстань).  Цікаво відзначити, що шлях до Дніпра через Київ та Черкаси (1094 км) виявився коротшим, ніж шлях через Полтаву (1169 км), що демонструє здатність алгоритму знаходити нетривіальні оптимальні маршрути.**

![](https://github.com/AnatoliiNovyk/goit-algo-hw-06/blob/main/images/graph_citys_3.png)

------------

### Загальний висновок
**Це домашнє завдання дозволило на практиці застосувати фундаментальні алгоритми теорії графів. Ми навчилися моделювати мережі, візуалізувати їх, аналізувати структуру та використовувати алгоритми DFS, BFS і Дейкстри для вирішення практичних задач пошуку шляхів.**