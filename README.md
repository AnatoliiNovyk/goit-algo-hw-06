# goit-algo-hw-06
## Домашнє завдання №6: Алгоритми на графах
У цьому домашньому завданні ми досліджуємо основні алгоритми на графах, використовуючи бібліотеку networkX у Python. Ми змоделюємо реальну мережу, реалізуємо алгоритми пошуку шляхів (DFS, BFS), а також знайдемо найкоротші маршрути за допомогою алгоритму Дейкстри.

### Завдання 1: Моделювання та аналіз реальної мережі
Для першого завдання я створив модель транспортної мережі, що сполучає великі міста України. Цей граф є неорієнтованим, де вершини — це міста, а ребра — основні автомобільні шляхи між ними.

Код для створення та візуалізації графа

```python
import networkx as nx
import matplotlib.pyplot as plt

# Створення неорієнтованого графа
G = nx.Graph()

# Додавання вузлів (міст)
cities = ["Київ", "Львів", "Одеса", "Харків", "Дніпро", "Запоріжжя", "Вінниця", "Полтава", "Черкаси", "Кривий Ріг"]
G.add_nodes_from(cities)

# Додавання ребер (доріг між містами)
edges = [
    ("Київ", "Вінниця"), ("Київ", "Черкаси"), ("Київ", "Полтава"),
    ("Вінниця", "Львів"), ("Вінниця", "Одеса"),
    ("Одеса", "Черкаси"), ("Одеса", "Кривий Ріг"),
    ("Черкаси", "Полтава"), ("Черкаси", "Дніпро"),
    ("Полтава", "Харків"), ("Полтава", "Дніпро"),
    ("Дніпро", "Харків"), ("Дніпро", "Запоріжжя"), ("Дніпро", "Кривий Ріг"),
    ("Запоріжжя", "Кривий Ріг")
]
G.add_edges_from(edges)

# Візуалізація графа
plt.figure(figsize=(10, 8))
pos = nx.spring_layout(G, seed=42)  # для відтворюваності розташування вузлів
nx.draw(G, pos, with_labels=True, node_size=2500, node_color='skyblue', font_size=12, font_weight='bold', edge_color='gray')
plt.title("Транспортна мережа міст України")
plt.show()
```

![](https://github.com/AnatoliiNovyk/goit-algo-hw-06/blob/main/images/graph_citys.png)


**Аналіз основних характеристик графа**

Проведемо аналіз базових метрик створеного графа.

```python
# Аналіз характеристик графа
num_nodes = G.number_of_nodes()
num_edges = G.number_of_edges()
degrees = dict(G.degree())

print(f"Кількість вершин (міст): {num_nodes}")
print(f"Кількість ребер (шляхів): {num_edges}")
print("\nСтупені вершин (кількість зв'язків для кожного міста):")
for city, degree in degrees.items():
    print(f"- {city}: {degree}")
```

#### Результати аналізу:

- Кількість вершин (міст): 10 
- Кількість ребер (шляхів): 15 
- Ступені вершин: 
	- Київ: 3
	- Львів: 1
	- Одеса: 3
	- Харків: 2
	- Дніпро: 5
	- Запоріжжя: 2
	- Вінниця: 3
	- Полтава: 4
	- Черкаси: 4
	- Кривий Ріг: 3

#### Висновки:
**Місто Дніпро є найбільшим транспортним вузлом у даній моделі з найвищим ступенем (5), тоді як Львів є кінцевим вузлом, з'єднаним лише з Вінницею.**

------------

### Завдання 2: Алгоритми DFS та BFS
**На цьому етапі ми реалізуємо алгоритми пошуку в глибину (DFS) та в ширину (BFS) для знаходження шляхів у створеному графі.** 


#### Програмна реалізація DFS та BFS
Я реалізував два алгоритми для пошуку шляху між двома заданими містами: від Львова до Харкова.

```python
# Реалізація DFS для пошуку шляху
def dfs_path(graph, start, goal):
    stack = [(start, [start])]
    visited = {start}
    while stack:
        (vertex, path) = stack.pop()
        for neighbor in set(graph.neighbors(vertex)) - visited:
            if neighbor == goal:
                return path + [neighbor]
            visited.add(neighbor)
            stack.append((neighbor, path + [neighbor]))

# Реалізація BFS для пошуку шляху
def bfs_path(graph, start, goal):
    queue = [(start, [start])]
    visited = {start}
    while queue:
        (vertex, path) = queue.pop(0)
        for neighbor in set(graph.neighbors(vertex)) - visited:
            if neighbor == goal:
                return path + [neighbor]
            visited.add(neighbor)
            queue.append((neighbor, path + [neighbor]))

# Пошук шляхів між Львовом та Харковом
start_node = "Львів"
end_node = "Харків"

dfs_route = dfs_path(G, start_node, end_node)
bfs_route = bfs_path(G, start_node, end_node)

print(f"Шлях знайдений за допомогою DFS: {dfs_route}")
print(f"Шлях знайдений за допомогою BFS: {bfs_route}")
```


#### Порівняння результатів та обґрунтування
**Результати пошуку:**

- **Шлях, знайдений за допомогою DFS:** ['Львів', 'Вінниця', 'Одеса', 'Кривий Ріг', 'Запоріжжя', 'Дніпро', 'Харків']
- **Шлях, знайдений за допомогою BFS:** ['Львів', 'Вінниця', 'Київ', 'Полтава', 'Харків']


#### Пояснення різниці: 

**1.Пошук у глибину (DFS):** Цей алгоритм працює за принципом "йди якомога глибше".  Починаючи зі Львова, він рухається до першого сусіда (Вінниця), потім до першого сусіда Вінниці (крім Львова), і так далі. У моїй реалізації він обрав шлях через Одесу, Кривий Ріг, Запоріжжя і Дніпро, перш ніж досягти Харкова. DFS не гарантує знаходження найкоротшого шляху; він знаходить будь-який шлях, досліджуючи одну гілку графа повністю, перш ніж повернутися до інших. 

**2.Пошук у ширину (BFS):** Цей алгоритм досліджує граф по рівнях.  Він спочатку відвідує всіх сусідів стартової вершини, потім сусідів цих сусідів і т.д. Починаючи зі Львова, він знайшов Вінницю (рівень 1). Потім він дослідив усіх сусідів Вінниці (Київ та Одеса, рівень 2). Далі він перевірив сусідів Києва та Одеси (рівень 3) і знайшов шлях до Харкова через Київ та Полтаву. BFS завжди знаходить найкоротший шлях у незваженому графі за кількістю ребер, оскільки він систематично розширюється від стартової точки.

#### Обґрунтування: 
**Різниця у шляхах є прямим наслідком механіки роботи алгоритмів. DFS використовує стек (LIFO), що веде його вглиб по одному маршруту. BFS використовує чергу (FIFO), що змушує його досліджувати граф пошарово, гарантуючи оптимальність шляху за кількістю пройдених вершин.**

------------

### Завдання 3: Алгоритм Дейкстри для пошуку найкоротших шляхів
**У цьому завданні було вирішено задачу пошуку оптимальних маршрутів у зваженому графі, що моделює транспортну мережу України.** 

#### 1. Моделювання та зважування графа
- ДЗа основу було взято граф, розроблений у **Завданні 1**.
- Для застосування алгоритму Дейкстри граф було перетворено на зважений. Ваги ребер представляють реальні приблизні відстані в кілометрах між містами, що забезпечує реалістичність моделі.

#### 2. Реалізація алгоритму Дейкстри
- Згідно з ключовою вимогою, алгоритм Дейкстри було реалізовано програмно з нуля, що дозволило глибоко зрозуміти його логіку.
- Для ефективності у реалізації використано пріоритетну чергу (`heapq`).
- Функція реалізована таким чином, щоб повертати не тільки найкоротші відстані, але й словник попередніх вершин. Це дозволяє відновити та візуалізувати сам маршрут, а не лише дізнатись його довжину.
- Для надійності в документацію функції додано її головне обмеження (непридатність для графів з негативними вагами), а в код — обробку можливих помилок.

#### 3. Аналіз результатів
- Скрипт демонструє не тільки довжину найкоротшого шляху, але й сам маршрут у вигляді послідовності міст (наприклад, `Ужгород -> Львів -> Київ -> Харків`).
- Це наочно ілюструє різницю між **BFS** (який знаходить шлях з найменшою кількістю зупинок) та **Дейкстрою** (який знаходить шлях з найменшим сумарним кілометражем, що є значно ціннішим для практичних задач).

#### 4. Висновки
Це завдання успішно демонструє застосування класичного алгоритму Дейкстри для вирішення практичної задачі пошуку оптимальних маршрутів у зваженій мережі. Було підтверджено, що ця реалізація дозволяє гнучко керувати процесом та глибоко розуміти фундаментальні принципи роботи графових алгоритмів.

------------

### Загальний висновок
**Це домашнє завдання дозволило на практиці застосувати фундаментальні алгоритми теорії графів. Ми навчилися моделювати мережі, візуалізувати їх, аналізувати структуру та використовувати алгоритми DFS, BFS і Дейкстри для вирішення практичних задач пошуку шляхів.**